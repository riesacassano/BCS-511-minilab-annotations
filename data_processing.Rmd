---
title: "Data processing"
author: "Riesa Cassano"
date: "3/18/2022"
output: html_document
---

```{r libraries, include=FALSE}
library(tidyverse)
library(magrittr)
```

```{r load data, include=FALSE}
# load data
d <- as_tibble(read.csv('data/raw.csv'))

# convert exp_subject_id to a factor
d <- mutate(d, exp_subject_id = as.factor(exp_subject_id))
```

Post-experiment survey data is saved for all subjects who completed it in `survey.csv`. 

```{r process survey data, echo=FALSE}
# get the survey answers and put them in a separate tibble and save
survey_qs <- c('Frequenc','Instr','hour','num_instru','name_instru','age_range',
               'best_instru','music_theory','listen_time','genre1','genre2',
               'genre3','earworm','imagery1','imagery2','imagery3','ab_pitch',
               'relative_pitch','exp_subject_id','familiarity','played_notplayed')

d.survey <- d %>%
  # filter out rows not related to survey
  filter(Block_Name == 'post_survey') %>%
  # only grab survey answers
  select(all_of(survey_qs)) %>%
  # put subject ID at front
  relocate(exp_subject_id) %>%
  #write_csv('data/survey.csv')
  print()
```

```{r initial string processing function for responses, echo=FALSE}
process_responses <- function(data){
  # from the raw version to a list separated by semicolons
  
  # if the subjects didn't respond then the entry will be returned as ""
  data[data==""] <- "values= " 

  all_vals <- data %>%
    strsplit("values=") %>%
    transpose()
  all_vals <- flatten(all_vals[2])
  all_vals <- sub('\"', '', all_vals) # remove \" from the end
  all_vals <- substring(all_vals, 2) # remove first ;
  return(all_vals)
}
```


Everything related to the practice task is saved in `practice_task.csv`.

```{r process everything related to practice task, echo=FALSE}
d.practice <- d %>%
  # filter out rows not related to practice task 
  filter(grepl('practice', Task_Name)) %>%
  # we want columns related to practice task
  select(c('exp_subject_id','factor1_tg1_task28',
           'space_press1','space_press2','strategy')) %>%
  # rename practice task column for readability
  rename('practice_task' = 'factor1_tg1_task28')

# text processing of the space presses
space_press1_vals.pr <- process_responses(d.practice$space_press1)
space_press2_vals.pr <- process_responses(d.practice$space_press2)

d.practice <- mutate(d.practice,
                     response1_vals = space_press1_vals.pr,
                     response2_vals = space_press2_vals.pr,
                     space_press1 = NULL,
                     space_press2 = NULL)

d.strat_temp <- d.practice[seq(1, nrow(d.practice), 2),]
d.strat_temp <- select(d.strat_temp, c(exp_subject_id, strategy))
#print(d.strat_temp)

d.other_temp <- d.practice[seq(2, nrow(d.practice), 2),]
d.other_temp <- select(d.other_temp, -strategy)
#print(d.other_temp)

d.practice_filtered <- d.other_temp
d.practice_filtered$strategy <- d.strat_temp$strategy
#write_csv(d.practice_filtered, 'data/practice_task.csv')
print(d.practice_filtered)
```

Responses for the actual task are processed similarly. Responses and strategy answers are extracted together from the raw file and then separated. Strategy answers are saved in `strategy.csv`

```{r get all rows for actual task and process strategy, echo=FALSE}
d.responses_all_strat <- d %>%
  # keep only rows for main task (this includes response task and strategy)
  filter(grepl('block_', Block_Name)) %>%
  # keep relevant columns
  select(c('exp_subject_id','Task_Name',
           'space_press1','space_press2','strategy')) #%>%
  #print()

d.strategy <- d.responses_all_strat %>%
  # strategy questions are labeled with 25%, 50%, 75%, or 100%
  # matching the subject's progress through the experiment
  filter(grepl('%', Task_Name)) %>%
  # drop the (now empty) response columns
  select(c(-space_press1, -space_press2)) %>%
  #write_csv('data/strategy.csv')
  print()
```

Check that each subject actually completed the experiment. For any given stimulus a subject may not have responded at any point during that stimulus. If that is the case, the stimulus itself will still show up as a row, but the values in the response column will be "". These cases are kept. If a subject doesn't have rows for one or more stimulus, then they stopped early and their data is not included.

```{r check for completeness, echo=FALSE}
d.responses_all <- d.responses_all_strat %>%
  # remove the strategy rows and column
  mutate(strategy = NULL) %>%
  filter(!grepl('%', Task_Name)) %>%
  print()

subj_ids <- levels(d.responses_all$exp_subject_id)
for (i in 1:length(subj_ids)){
  n_stim <- nrow(filter(d.responses_all, exp_subject_id == subj_ids[i]))
  print(c(subj_ids[i],n_stim))
}
```

This list shows us all subjects, including those who failed the headphone check and heard 0 stimuli. The only subject with an incomplete set of data is `377660`. They are filtered out before the responses are saved. There are 18 subjects who completed all 12 stimuli.

```{r save responses, echo=FALSE}
space_press1_vals <- process_responses(d.responses_all$space_press1)
space_press2_vals <- process_responses(d.responses_all$space_press2)

d.responses_all <- d.responses_all %>%
  mutate(
    response1_vals = space_press1_vals,
    response2_vals = space_press2_vals,
    space_press1 = NULL,
    space_press2 = NULL) %>%
  # filter the subject with incomplete data
  filter(exp_subject_id != 377660)
  
# separate condition and stimulus number into separate columns
stimulus <- transpose(str_split(d.responses_all$Task_Name,"_"))
  
d.responses_all %<>%
  mutate(
    scram_cond = as.character(stimulus[[1]]),
    stim_num = as.character(stimulus[[2]]),
    Task_Name = NULL
  ) %>%
  relocate(c(scram_cond, stim_num), .after=exp_subject_id) %>%
  #write_csv('data/responses_timestamps.csv')
  print()
```

As a final processing step, we'll represent the responses as binary vectors. For this we'll bin into one-second bins. 1 represents seconds where a responses occurred in that second, and 0 represents seconds where no response occurred in that second. Since not all of the stimuli are the same length, there are variable amounts of padding added to the end of each binary vector (maximum 6 seconds).

```{r process?, echo=FALSE}

process_responses_to_dbls <- function(data){
  # separate values for use as a list of doubles
  processed_data <- c()
  for (i in 1:length(data)){
    vals = flatten(strsplit(toString(data[i][1]), ";"))
    #vals = vals[-1] # remove first value (empty)
    #vals = sub('\"', '', vals) # remove \" from last value
    vals = as.numeric(as.list(vals)) # save as a list of numerics
    vals = as_tibble(vals / 1000) # convert ms to s and make a tibble
    processed_data <- c(processed_data,vals)
  }
  return(processed_data)
}

```

```{r binarize responses, echo=FALSE}
d.binarized <- d.responses_all %>%
  # put all responses in one column
  pivot_longer(c('response1_vals','response2_vals'),
               names_to='run_col',values_to='response_vals') %>%
  mutate(run = ifelse(run_col=='response1_vals',1,2), run_col = NULL) %>%
  relocate(run,.before='response_vals')

# The longest stimulus is 1:25, so the binary vectors are at most 85 seconds long.
response_vec_length <- 85
# There are three "identification" columns (exp_subject_id, Task_Name, run) and then the data (response_vals)
id_cols <- ncol(d.binarized)

# add the columns of zeros
seconds <- as.character(0:response_vec_length)
d.binarized[seconds] <- 0

# use response_vals to determine which seconds have a response in them
for (i in 1:nrow(d.binarized)){
  
  # grab the response values for this row
  these_vals <- d.binarized$response_vals[i]
  
  # if there are no responses, move on to the next row
  if (these_vals == "") {next}
  
  # separate the values 
  these_vals <- as.numeric(unlist(strsplit(these_vals, ";")))
  
  # convert milliseconds to seconds 
  # and convert doubles to integers to drop what's after the decimal point
  these_vals <- as.integer(these_vals / 1000)
  
  # use those values to index in the columns we created
  for (j in these_vals){
    d.binarized[[j+id_cols+1]][i] <- 1 # id_cols+1 is for '0'
  }
  
}

d.binarized$response_vals <- NULL
write_csv(d.binarized, 'data/responses_binarized.csv')
#print(d.binarized)

```